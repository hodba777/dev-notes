{
  "readme_content": "# Cross-Chain Bridge Event Listener Simulation\n\nThis repository contains a Python script that simulates the core logic of an event listener and transaction relayer for a cross-chain bridge. It is designed to be a robust, well-architected component of a larger decentralized system, showcasing best practices in code structure, error handling, and external service interaction.\n\n## Concept\n\nA cross-chain bridge allows users to transfer assets or data from one blockchain (the \"source chain\") to another (the \"destination chain\"). The fundamental mechanism often involves:\n1.  A user locking or depositing assets into a smart contract on the source chain.\n2.  This action emits an event, which is a verifiable log on the blockchain.\n3.  Off-chain services, known as \"listeners\" or \"relayers,\" detect this event.\n4.  After validating the event, the relayer initiates a transaction on the destination chain to mint or release an equivalent amount of a corresponding asset to the user.\n\nThis script simulates steps 3 and 4. It actively listens for `DepositMade` events on a source chain, validates the event data against a mock compliance API, and then simulates the creation and broadcast of a corresponding `releaseTokens` transaction on the destination chain.\n\n## Code Architecture\n\nThe script is designed with a clear separation of concerns, organized into several distinct classes that work together. This modular architecture makes the system easier to understand, maintain, and extend.\n\n```\n+-----------------------+      +------------------+      +---------------------------+\n|                       |      |                  |      |                           |\n|  BridgeOrchestrator   |----->|   EventScanner   |----->|    BlockchainConnector    |\n|     (Main Loop)       |      | (Polls for events) |      | (Source Chain - Web3.py)  |\n|                       |      |                  |      |                           |\n+-----------+-----------+      +------------------+      +---------------------------+\n            |\n            | (Dispatches validated events)\n            v\n+-----------+-----------+      +------------------+      +-----------------------------+\n|                       |      |                  |      |                             |\n|  TransactionRelayer   |----->|  MockAPIClient   |----->|     BlockchainConnector     |\n| (Validates & Relays)  |      |  (Compliance)    |      | (Destination Chain - Web3.py) |\n|                       |      |   (requests)     |      |                             |\n+-----------------------+      +------------------+      +-----------------------------+\n```\n\n### Core Components:\n\n*   **`BlockchainConnector`**: A generic wrapper around the `web3.py` library. It manages the connection to a single blockchain via its RPC endpoint. It provides methods to fetch chain data (like the latest block number) and interact with smart contracts. Two instances of this class are created: one for the source chain and one for the destination chain.\n\n*   **`EventScanner`**: This class is responsible for polling the source chain for new events. It maintains its state (the last block it scanned) and intelligently queries for new blocks, respecting a confirmation delay to protect against blockchain reorganizations. It uses a `BlockchainConnector` to perform its tasks.\n\n*   **`MockAPIClient`**: Simulates an external REST API service, for example, a compliance service that checks addresses against a sanctions list. It uses the `requests` library to make HTTP calls. This demonstrates how a blockchain component can interact with traditional off-chain services.\n\n*   **`TransactionRelayer`**: The heart of the relayer logic. It receives events from the `EventScanner`, performs validation checks (including calling the `MockAPIClient`), and, if the event is valid, constructs and simulates sending a transaction to the destination chain. It also handles duplicate event processing by tracking nonces.\n\n*   **`BridgeOrchestrator`**: The top-level class that initializes and coordinates all other components. It contains the main execution loop that periodically triggers the event scanner and dispatches found events to the relayer.\n\n## How it Works\n\nThe script follows a continuous operational loop:\n\n1.  **Initialization**: The `BridgeOrchestrator` is instantiated. It sets up `BlockchainConnector` instances for both the source (e.g., Sepolia) and destination (e.g., Linea Goerli) chains using public RPC URLs.\n2.  **Contract Setup**: It creates `web3.py` contract objects using the provided addresses and ABIs for the bridge contracts on both chains.\n3.  **Loop Start**: The orchestrator's `run()` method begins the main loop.\n4.  **Scanning**: Inside the loop, the `EventScanner` is called. It determines the correct range of blocks to query (from its last scanned block up to the latest block minus a safety confirmation margin).\n5.  **Event Detection**: It filters this block range for `DepositMade` events from the source bridge contract. \n6.  **Dispatch**: If new, confirmed events are found, they are passed one by one to the `TransactionRelayer`.\n7.  **Validation**: For each event, the `TransactionRelayer` performs two key checks:\n    *   It ensures the event's unique `nonce` has not been processed before to prevent double-spending.\n    *   It calls the `MockAPIClient` to check if the depositor's address is compliant.\n8.  **Relaying (Simulation)**: If all checks pass, the relayer constructs the payload for the `releaseTokens` function call on the destination contract. It then logs the details of this transaction to the console, simulating the act of signing and broadcasting it.\n9.  **State Update**: The relayer adds the event's `nonce` to its set of processed nonces.\n10. **Wait**: The loop then pauses for a configurable `poll_interval` (e.g., 15 seconds) before starting the next scanning cycle.\n\n## Getting Started\n\nFollow these steps to run the bridge listener simulation.\n\n### 1. Prerequisites\n\n*   Python 3.8+\n*   `pip` package manager\n\n### 2. Setup\n\nFirst, clone the repository and navigate into the project directory.\n\n```bash\ngit clone https://github.com/your-username/your-repo-name.git\ncd your-repo-name\n```\n\nCreate a Python virtual environment and activate it:\n\n```bash\npython -m venv venv\nsource venv/bin/activate  # On Windows, use `venv\\Scripts\\activate`\n```\n\nInstall the required Python libraries from the `requirements.txt` file:\n\n```bash\npip install -r requirements.txt\n```\n\n### 3. Configuration (Optional)\n\nThe script is pre-configured to use public RPC endpoints for the Sepolia and Linea Goerli testnets. You can override these by creating a `.env` file in the root directory:\n\n```.env\nSOURCE_CHAIN_RPC_URL=https://your-sepolia-rpc-url.com\nDEST_CHAIN_RPC_URL=https://your-linea-goerli-rpc-url.com\n```\n\n### 4. Running the Script\n\nExecute the script from your terminal:\n\n```bash\npython script.py\n```\n\nThe `script.py` file's entry point initializes and runs the `BridgeOrchestrator`:\n\n```python\n# script.py\n\nif __name__ == \"__main__\":\n    try:\n        # The BridgeOrchestrator class ties all components together.\n        orchestrator = BridgeOrchestrator(\n            start_block=4598123,  # Example start block for Sepolia\n            poll_interval=15,\n            confirmations=6\n        )\n        orchestrator.run()\n    except KeyboardInterrupt:\n        print(\"\\n[!] User interrupted process. Shutting down.\")\n    except Exception as e:\n        print(f\"\\n[X] An unexpected error occurred: {e}\")\n\n```\n\nThe listener will start, and you will see log messages indicating its status.\n\n### Expected Output\n\nInitially, the script will establish connections and start scanning:\n\n```\n2023-10-27 15:30:00,123 - INFO - [BridgeOrchestrator] - Initializing Bridge Orchestrator...\n2023-10-27 15:30:01,456 - INFO - [BlockchainConnector] - Successfully connected to SourceChain (Sepolia) at https://rpc.sepolia.org. Chain ID: 11155111\n2023-10-27 15:30:02,789 - INFO - [BlockchainConnector] - Successfully connected to DestinationChain (Linea Goerli) at https://rpc.goerli.linea.build. Chain ID: 59140\n2023-10-27 15:30:02,790 - INFO - [EventScanner] - EventScanner for 'DepositMade' on SourceChain (Sepolia) initialized. Starting scan from block 4598123.\n2023-10-27 15:30:02,791 - INFO - [BridgeOrchestrator] - Orchestrator initialized successfully.\n2023-10-27 15:30:02,792 - INFO - [BridgeOrchestrator] - Starting bridge listener event loop...\n```\n\nWhen waiting for new blocks, it will log:\n\n```\n2023-10-27 15:30:15,111 - INFO - [EventScanner] - Scanning for 'DepositMade' events from block 4598124 to 4598130 on SourceChain (Sepolia).\n2023-10-27 15:30:17,222 - INFO - [BridgeOrchestrator] - No new events found. Waiting for next poll cycle.\n```\n\nIf it finds and processes an event, the output will look like this:\n\n```\n2023-10-27 15:31:00,333 - INFO - [EventScanner] - Found 1 new 'DepositMade' event(s).\n2023-10-27 15:31:00,334 - INFO - [TransactionRelayer] - Processing event with nonce 101: {'sender': '0x...', 'recipient': '0x...', 'amount': 100000000, ...}\n2023-10-27 15:31:00,335 - INFO - [MockAPIClient] - Performing mock compliance check for address: 0x...\n2023-10-27 15:31:01,555 - INFO - [MockAPIClient] - Compliance API check successful for 0x.... Status: 200\n2023-10-27 15:31:01,556 - INFO - [TransactionRelayer] - Validation successful for nonce 101. Relaying transaction to DestinationChain (Linea Goerli).\n2023-10-27 15:31:01,557 - INFO - [TransactionRelayer] - [SIMULATION] Building 'releaseTokens' transaction for recipient 0x..., amount 100000000, nonce 101\n--------------------------------------------------\n[!!!] SIMULATED TRANSACTION RELAYED [!!!]\n    -> TO:   DestinationChain (Linea Goerli)\n    -> FUNC: releaseTokens(recipient, amount, sourceNonce)\n    -> DATA: recipient=0x..., amount=100000000, sourceNonce=101\n--------------------------------------------------\n```"
}